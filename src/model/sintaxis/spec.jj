options {
	STATIC=false;
	DEBUG_PARSER=true;
}

PARSER_BEGIN(ConstructorASTsJJ)
package model.sintaxis;

import model.sintaxis.SintaxisAbstracta.Prog;
import model.sintaxis.SintaxisAbstracta.Bloque;
import model.sintaxis.SintaxisAbstracta.Decs_opt;
import model.sintaxis.SintaxisAbstracta.Decs;
import model.sintaxis.SintaxisAbstracta.Dec;
import model.sintaxis.SintaxisAbstracta.Tipo;
import model.sintaxis.SintaxisAbstracta.Campos;
import model.sintaxis.SintaxisAbstracta.Campo;
import model.sintaxis.SintaxisAbstracta.LParam_opt;
import model.sintaxis.SintaxisAbstracta.LParam;
import model.sintaxis.SintaxisAbstracta.Param;
import model.sintaxis.SintaxisAbstracta.Instrs_opt;
import model.sintaxis.SintaxisAbstracta.Instrs;
import model.sintaxis.SintaxisAbstracta.Instr;
import model.sintaxis.SintaxisAbstracta.Exps_opt;
import model.sintaxis.SintaxisAbstracta.Exps;
import model.sintaxis.SintaxisAbstracta.Exp;
import model.lexico.UnidadLexica.StringLocalizado;

public class ConstructorASTsJJ {
  private ClaseSemantica sem = new ClaseSemantica();
}
PARSER_END(ConstructorASTsJJ)

	TOKEN:{<#Letra:["a"-"z","A"-"Z", "_"]>}
	TOKEN:{<#DigitoPositivo:["1"-"9"]>}
	TOKEN:{<#Digito:<DigitoPositivo>|"0">}
	TOKEN:{<#ParteEntera:<DigitoPositivo> (<Digito>)* |"0">}
	TOKEN:{<#ParteDecimal: <Acceso>((<Digito>)*<DigitoPositivo>|"0")>}
	TOKEN:{<#ParteExponencial:("e"|"E") (["+", "-"])? <ParteEntera>>}
	TOKEN:{<#ComboPartes:<ParteDecimal><ParteExponencial>>}

	TOKEN:{<Entero:("i"|"I")("n"|"N")("t"|"T")>}
	TOKEN:{<Real:("r"|"R")("e"|"E")("a"|"A")("l"|"L")>}
	TOKEN:{<Boolean:("b"|"B")("o"|"O")("o"|"O")("l"|"L")>}
	TOKEN:{<String:("s"|"S")("t"|"T")("r"|"R")("i"|"I")("n"|"N")("g"|"G")>}
	TOKEN:{<LiteralTrue:("t"|"T")("r"|"R")("u"|"U")("e"|"E")>}
	TOKEN:{<LiteralFalse:("f"|"F")("a"|"A")("l"|"L")("s"|"S")("e"|"E")>}
	TOKEN:{<And:("a"|"A")("n"|"N")("d"|"D")>}
	TOKEN:{<Or:("o"|"O")("r"|"R")>}
	TOKEN:{<Not:("n"|"N")("o"|"O")("t"|"T")>}
	TOKEN:{<Null:("n"|"N")("u"|"U")("l"|"L")("l"|"L")>}
	TOKEN:{<Proc:("p"|"P")("r"|"R")("o"|"O")("c"|"C")>}
	TOKEN:{<If:("i"|"I")("f"|"F")>}
	TOKEN:{<Else:("e"|"E")("l"|"L")("s"|"S")("e"|"E")>}
	TOKEN:{<While:("w"|"W")("h"|"H")("i"|"I")("l"|"L")("e"|"E")>}
	TOKEN:{<Struct:("s"|"S")("t"|"T")("r"|"R")("u"|"U")("c"|"C")("t"|"T")>}
	TOKEN:{<New:("n"|"N")("e"|"E")("w"|"W")>}
	TOKEN:{<Delete:("d"|"D")("e"|"E")("l"|"L")("e"|"E")("t"|"T")("e"|"E")>}
	TOKEN:{<Read:("r"|"R")("e"|"E")("a"|"A")("d"|"D")>}
	TOKEN:{<Write:("w"|"W")("r"|"R")("i"|"I")("t"|"T")("e"|"E")>}
	TOKEN:{<Nl:("n"|"N")("l"|"L")>}
	TOKEN:{<Type:("t"|"T")("y"|"Y")("p"|"P")("e"|"E")>}
	TOKEN:{<Call:("c"|"C")("a"|"A")("l"|"L")("l"|"L")>}
	TOKEN:{<Identificador: <Letra> (<Letra> | <Digito>)*>}

	TOKEN:{<LiteralEntero: (["+", "-"])? <ParteEntera>>}
	TOKEN:{<LiteralReal: <LiteralEntero> (<ParteDecimal> | <ParteExponencial> | <ComboPartes> )>}
	TOKEN:{<LiteralString: "\"" (~["\""])* "\"">}

	TOKEN:{<Suma:"+">}
	TOKEN:{<Resta:"-">}
	TOKEN:{<Mul:"*">}
	TOKEN:{<Div:"/">}
	TOKEN:{<Modulo:"%">}
	TOKEN:{<Puntero: "^">}
	TOKEN:{<Referencia: "&">}
	TOKEN:{<MenorQue:"<">}
	TOKEN:{<MayorQue:">">}
	TOKEN:{<MenorOIgualQue:"<=">}
	TOKEN:{<MayorOIgualQue:">=">}
	TOKEN:{<Igual:"==">}
	TOKEN:{<Diferente:"!=">}
	TOKEN:{<Asignacion:"=">}
	TOKEN:{<PyC:";">}
	TOKEN:{<ParAp:"(">}
	TOKEN:{<ParCierre:")">}
	TOKEN:{<CorcheteApertura:"[">}
	TOKEN:{<CorcheteCierro:"]">}
	TOKEN:{<LlaveApertura:"{">}
	TOKEN:{<LlaveCierre:"}">}
	TOKEN:{<Acceso:".">}
	TOKEN:{<Coma:",">}
	TOKEN:{<FinDeclaracion:"&&">}
	TOKEN:{<Evalua:"@">}

	SKIP:{<["\t"," ","\r","\b","\n"]>}
	SKIP:{<"##"((~["\n"]))*>}

Prog analiza() :
    {Prog prog;}
    {
      prog = programa() <EOF>
        {return prog;}
    }
Prog programa():
    {Bloque bq;}
    {
      bq = bloque()
        {return sem.prog(bq);}
    }
Bloque bloque():
    {Decs_opt decs; Instrs_opt instrs;}
    {
      <LlaveApertura> decs = declaraciones_opt() instrs = instrucciones_opt() <LlaveCierre>
        {return sem.bloque(decs, instrs);}
    }
Decs_opt declaraciones_opt():
    {Decs decs;}
    {
      decs = declaraciones() <FinDeclaracion>
        {return sem.si_decs(decs);}
      |
        {return sem.no_decs();}
    }
Decs declaraciones():
    {Decs decs; Dec dec;}
    {
      dec = declaración() decs = r_declaraciones(sem.una_dec(dec))
        {return decs}
    }
Decs r_declaraciones(Decs decsh):
    {Decs decs; Dec dec;}
    {
      <PyC> dec = declaración() decs = r_declaraciones(sem.l_decs(decsh, dec))
        {return decs;}
      |
        {return decsh;}
    }
Dec declaración():
    {Dec dec;}
    {
      dec = dec_variable()
        {return dec;}
      |
      dec = dec_tipo()
        {return dec;}
      |
      dec = dec_procedimiento()
        {return dec;}
    }

Dec dec_tipo():
    {Tipo tipo; Token id;}
    {
      <Type> tipo = tipo0() id = <Identificador>
        {return (Dec)sem.t_dec(tipo, id.image).ponFila(id.beginLine).ponCol(id.beginColumn);}
    }

Dec dec_variable():
    {Tipo tipo; Token id;}
    {
      tipo = tipo0() id = <Identificador>
        {return (Dec)sem.v_dec(tipo, id.image).ponFila(id.beginLine).ponCol(id.beginColumn);}
    }
Tipo tipo0():
    {Tipo tipo; Tipo rtipo}
    {
      tipo=tipo1() rtipo = r_tipo0(tipo)
        { return rtipo; }
    }
Tipo r_tipo0(Tipo tipoh):
    {Token cap; Tipo rtipo}
    {
      <CorcheteApertura> cap = <LiteralEntero> <CorcheteCierro> rtipo = r_tipo0((Tipo)sem.a_tipo(tipoh, cap.image).ponFila(cap.beginLine).ponCol(cap.beginColumn))
        {return rtipo;}
      |
        {return tipoh;}
    }
Tipo tipo1():
    {Tipo tipo;}
    {
      <Puntero> tipo = tipo1()
        {return sem.p_tipo(tipo);}
      |
      tipo = tipo2()
        {return tipo;}
    }
Tipo tipo2():
    {Tipo tipo; Token id;}
    {
      <Entero>
        {return sem.in_tipo();}
      |
      <Real>
        {return sem.r_tipo();}
      |
      <Boolean>
        {return sem.b_tipo();}
      |
      <String>
        {return sem.string_tipo();}
      |
      id = <Identificador>
        {return (Tipo)sem.id_tipo(id.image).ponFila(id.beginLine).ponCol(id.beginColumn));}
      |
      tipo = registro()
        {return tipo;}
    }
Tipo registro():
    {Campos campos;}
    {
      <Struct> <LlaveApertura> campos = campos() <LlaveCierre>
        {return sem.struct_tipo(campos);}
    }
Campos campos():
    {Campos campos; Campo campo;}
    {
      campo = campo() campos = r_campos(sem.un_campo(campo))
        {return campos;}
    }
Campos r_campos(Campos camposh):
    {Campos campos; Campo campo;}
    {
      <Coma> campo = campo() campos = r_campos(sem.l_campos(camposh, campo))
        {return campos;}
      |
        {return camposh;}
    }
Campo campo():
    {Tipo tipo; Token id;}
    {
      tipo = tipo0() id = <Identificador>
        {return (Campo)sem.camp(tipo, id.image).ponFila(id.beginLine).ponCol(id.beginColumn);}
    }

void dec_procedimiento(): {} { <Proc> <Identificador> parametros_formales() bloque() }
void parametros_formales(): {} { "(" lista_parametros_opt() ")" }
void lista_parametros_opt(): {} { lista_parametros() | {} }
void lista_parametros(): {} { parametro() r_lista_parametros() }
void r_lista_parametros(): {} { "," parametro() r_lista_parametros() | {} }
void parametro(): {} { tipo0() r_parametro() }
void r_parametro(): {} { <Identificador> | "&" <Identificador> }

void instrucciones_opt(): {} { instrucciones() | {} }
void instrucciones(): {} { instruccion() r_instrucciones() }
void r_instrucciones(): {} { ";" instruccion() r_instrucciones() | {} }
void instruccion(): {} { instruccion_eval() | instruccion_if() | instruccion_while() | instruccion_read() | instruccion_write() | instruccion_nl() | instruccion_new() | instruccion_delete() | instruccion_call() | instruccion_compuesta() }
void instruccion_eval(): {} { "@" E0() }
void instruccion_if(): {} { <If> E0() bloque() r_instruccion_if() }
void r_instruccion_if(): {} { <Else> bloque() | {} }
void instruccion_while(): {} { <While> E0() bloque() }
void instruccion_read(): {} { <Read> E0() }
void instruccion_write(): {} { <Write> E0() }
void instruccion_nl(): {} { <Nl> }
void instruccion_new(): {} { <New> E0() }
void instruccion_delete(): {} { <Delete> E0() }
void instruccion_call(): {} { <Call> <Identificador> "(" lista_expresiones_opt() ")" }
void instruccion_compuesta(): {} { bloque() }
void lista_expresiones_opt(): {} { lista_expresiones() | {} }
void lista_expresiones(): {} { E0() r_lista_expresiones() }
void r_lista_expresiones(): {} { "," E0() r_lista_expresiones() | {}}

void E0(): {} { E1() RE0() }
void RE0(): {} { "=" E0() | {} }
void E1(): {} { E2() RE1() }
void RE1(): {} { OP1() E2() RE1() | {} }
void E2(): {} { E3() R2E2() R1E2() }
void R1E2(): {} { "+" E3() R1E2() | {} }
void R2E2(): {} { "-" E3() | {} }
void E3(): {} { E4() RE3() }
void RE3(): {} { <And> E3() | <Or> E4() | {} }
void E4(): {} { E5() RE4() }
void RE4(): {} { OP4() E5() RE4() | {} }
void E5(): {} { OP5() E5() | E6() }
void E6(): {} { E7() RE6() }
void RE6(): {} { OP6() RE6() | {} }
void E7(): {} { "("E0()")" | operando() }
void OP1(): {} { ">" | "<" | <MenorOIgualQue> | <MayorOIgualQue> | <Igual> | <Diferente> }
void OP4(): {} { "*" | "/" | "%" }
void OP5(): {} { "-" | <Not> }
void OP6(): {} { "["E0()"]" | acceso_registro() | <Puntero> }
void acceso_registro(): {} { <Acceso> <Identificador> }
void operando(): {} { <LiteralReal> | <LiteralEntero> | <LiteralTrue> | <LiteralFalse> | <LiteralString> | <Identificador> | <Null> }